# Chomsky Normal Form (CNF)

## Theory

Chomsky Normal Form (CNF) is a standardized form for context-free grammars (CFGs). A CFG is in CNF if all of its
production rules are of one of the following forms:

1. `A -> BC` (where A, B, C are non-terminal symbols)
2. `A -> a` (where A is a non-terminal symbol and 'a' is a terminal symbol)
3. `S -> ε` (where S is the start symbol and ε is the empty string). If this rule exists, then S must not appear on the
   right-hand side of any rule.

Converting a grammar to CNF is a crucial preprocessing step for many parsing algorithms, most notably the
Cocke-Younger-Kasami (CYK) algorithm, which determines whether a given string can be generated by a particular
context-free grammar. CNF simplifies the structure of grammar rules, making them easier to work with algorithmically.

The conversion process typically involves several steps:

* **START**: (Optional, handled implicitly if needed) Ensure the start symbol does not appear on the right-hand side of
  any production. If it does, or if the language contains ε, a new start symbol `S'` is introduced with a rule
  `S' -> S`.
* **ELIMINATE ε-PRODUCTIONS**: Remove rules of the form `A -> ε`.
* **ELIMINATE UNIT PRODUCTIONS**: Remove rules of the form `A -> B` (where A and B are non-terminals).
* **ELIMINATE NON-PRODUCTIVE SYMBOLS**: Remove non-terminals that cannot derive any string of terminals.
* **ELIMINATE INACCESSIBLE SYMBOLS**: Remove symbols that cannot be reached from the start symbol.
* **TRANSFORM TO CNF FORM**: Convert remaining rules into the required `A -> BC` or `A -> a` forms. This often involves:
    * **TERM**: Ensuring that if a rule has a terminal on the right-hand side, that terminal is the only symbol on the
      RHS (e.g., `A -> a`). If terminals appear with other symbols (e.g., `A -> aB`), they are replaced by new
      non-terminals that derive them (e.g., `A -> X_a B`, `X_a -> a`).
    * **BIN**: Ensuring that rules with more than two non-terminals on the RHS are broken down (e.g., `A -> BCD` becomes
      `A -> BX_1`, `X_1 -> CD`).

The order of these steps can be important, and some steps (like eliminating non-productive and inaccessible symbols)
might need to be repeated.

## Objectives

* Understand the definition and significance of Chomsky Normal Form.
* Implement an algorithm to convert an arbitrary context-free grammar into CNF.
* Process a grammar defined in a specific textual format.
* Provide clear output of the grammar transformation at each step of the CNF conversion.

## Features

* **Grammar Parsing**: Parses context-free grammar definitions from a text file.
* **CNF Conversion**: Implements the full multi-step algorithm to convert a grammar to Chomsky Normal Form.
    * Step 1: Eliminate ε-productions.
    * Step 2: Eliminate unit productions.
    * Step 3: Eliminate non-productive symbols.
    * Step 4: Eliminate inaccessible symbols.
    * Step 5: Transform productions into the final CNF structure (`A -> BC` or `A -> a`).
    * Post-CNF Cleanup: Repeats elimination of unit, non-productive, and inaccessible symbols to ensure the final
      grammar is clean.
* **Step-by-Step Output**: Displays the state of the grammar after each transformation step, aiding in understanding and
  debugging the process.

## Implementation Description

This project is designed to parse a context-free grammar and convert it into Chomsky Normal Form (CNF). The
implementation is divided into several key Java classes, each with a specific role in the process.

### `GrammarParser.java`

This class is responsible for parsing a grammar definition provided as a string (typically read from a file like
`rules.txt`). It extracts the following components:

* **`V_N`**: The set of non-terminal symbols.
* **`V_T`**: The set of terminal symbols.
* **`P`**: The set of production rules.

The parser ensures the presence of a start symbol (defaulting to "S" if not specified) and validates that all symbols in
the production rules are defined as either non-terminals or terminals. It also recognizes epsilon productions (e.g.,
`A -> ε`). The primary method `parseFromString(String grammarDefinition)` returns a `Grammar` object.

```java
public Grammar parseFromString(String grammarDefinition) {
    // Parsing logic to extract V_N, V_T, and P
}
```

### `CNF.java`

This class implements the algorithm to convert a `Grammar` object into Chomsky Normal Form. The conversion process
involves multiple steps, each handled by a dedicated method. The main method `convertToCNF(Grammar grammar)`
orchestrates these steps and ensures correctness by applying cleanup phases iteratively.

#### Key Steps in CNF Conversion

1. **START**: Ensures the start symbol does not appear on the right-hand side of any production. If necessary, a new
   start symbol `S_0` is introduced with a rule `S_0 -> S`.
2. **Eliminate ε-Productions**: Removes rules of the form `A -> ε`. For every rule `B -> XAY` where `A` is nullable, a
   new rule `B -> XY` is added.

   ```java
   private Grammar eliminateEpsilonProductions(Grammar grammar) {
       // Logic to identify nullable symbols and generate new productions
   }
   ```

3. **Eliminate Unit Productions**: Removes rules of the form `A -> B` (where A and B are non-terminals). If `A -> B` and
   `B -> α` exist, then `A -> α` is added.

   ```java
   private Grammar eliminateUnitProductions(Grammar grammar) {
       // Logic to replace unit productions
   }
   ```

4. **Eliminate Non-Productive Symbols**: Removes non-terminals that cannot derive any sequence of terminal symbols.
5. **Eliminate Inaccessible Symbols**: Removes symbols that cannot be reached from the start symbol.
6. **Transform to CNF Form**: Converts remaining rules into the required forms:
    * **`A -> BC`**: For rules with two non-terminals on the right-hand side.
    * **`A -> a`**: For rules with a single terminal on the right-hand side.

   ```java
   public Grammar transformToChomskyForm(Grammar grammar) {
       // Logic to transform productions into CNF
   }
   ```

### `Main.java`

This class serves as the entry point for the application. It orchestrates the entire process:

1. Reads the grammar definition from a file (defaulting to `rules.txt` if no file path is provided).
2. Parses the grammar using `GrammarParser`.
3. Converts the parsed grammar to CNF using `CNF`.
4. Prints the original and final CNF grammar to the console.

```java
public static void main(String[] args) {
    // Argument handling and conversion logic
}
```

### Model Classes

These classes define the data structures for representing the grammar and its components:

* **`Grammar.java`**: Represents a context-free grammar as a 4-tuple `(V_N, V_T, S, P)`.

  ```java
  public record Grammar(Set<String> nonTerminals, Set<String> terminals, String startSymbol, Set<Production> rules) {
      // Overrides for easy printing
  }
  ```

* **`Production.java`**: Represents a single production rule, e.g., `S -> AB`.

  ```java
  public record Production(String left, List<ProductionSymbol> right) {
      // Overrides for easy printing
  }
  ```

* **`ProductionSymbol.java`**: Represents a symbol on the right-hand side of a production.

  ```java
  public record ProductionSymbol(String value, SymbolType type) {
      // Overrides for easy printing
  }
  ```

* **`SymbolType.java`**: An enum with values `TERMINAL` and `NON_TERMINAL` to classify symbols.

  ```java
  public enum SymbolType { TERMINAL, NON_TERMINAL }
  ```

## Conclusion

The Chomsky Normal Form (CNF) project provides a comprehensive implementation of grammar transformation techniques,
enabling the conversion of any context-free grammar into a standardized form. By following a structured multi-step
process, this project ensures that grammars are optimized for algorithmic applications like parsing and validation. The
step-by-step output and modular design make it a valuable tool for understanding and working with formal grammars in
computational theory.
