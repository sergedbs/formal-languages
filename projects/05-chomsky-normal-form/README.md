# Chomsky Normal Form (CNF)

## Theory

Chomsky Normal Form (CNF) is a standardized form for context-free grammars (CFGs). A CFG is in CNF if all of its production rules are of one of the following forms:

1. `A -> BC` (where A, B, C are non-terminal symbols)
2. `A -> a` (where A is a non-terminal symbol and 'a' is a terminal symbol)
3. `S -> ε` (where S is the start symbol and ε is the empty string). If this rule exists, then S must not appear on the right-hand side of any rule.

Converting a grammar to CNF is a crucial preprocessing step for many parsing algorithms, most notably the Cocke-Younger-Kasami (CYK) algorithm, which determines whether a given string can be generated by a particular context-free grammar. CNF simplifies the structure of grammar rules, making them easier to work with algorithmically.

The conversion process typically involves several steps:

* **START**: (Optional, handled implicitly if needed) Ensure the start symbol does not appear on the right-hand side of any production. If it does, or if the language contains ε, a new start symbol `S'` is introduced with a rule `S' -> S`.
* **ELIMINATE ε-PRODUCTIONS**: Remove rules of the form `A -> ε`.
* **ELIMINATE UNIT PRODUCTIONS**: Remove rules of the form `A -> B` (where A and B are non-terminals).
* **ELIMINATE NON-PRODUCTIVE SYMBOLS**: Remove non-terminals that cannot derive any string of terminals.
* **ELIMINATE INACCESSIBLE SYMBOLS**: Remove symbols that cannot be reached from the start symbol.
* **TRANSFORM TO CNF FORM**: Convert remaining rules into the required `A -> BC` or `A -> a` forms. This often involves:
  * **TERM**: Ensuring that if a rule has a terminal on the right-hand side, that terminal is the only symbol on the RHS (e.g., `A -> a`). If terminals appear with other symbols (e.g., `A -> aB`), they are replaced by new non-terminals that derive them (e.g., `A -> X_a B`, `X_a -> a`).
  * **BIN**: Ensuring that rules with more than two non-terminals on the RHS are broken down (e.g., `A -> BCD` becomes `A -> BX_1`, `X_1 -> CD`).

The order of these steps can be important, and some steps (like eliminating non-productive and inaccessible symbols) might need to be repeated.

## Objectives

* Understand the definition and significance of Chomsky Normal Form.
* Implement an algorithm to convert an arbitrary context-free grammar into CNF.
* Process a grammar defined in a specific textual format.
* Provide clear output of the grammar transformation at each step of the CNF conversion.

## Features

* **Grammar Parsing**: Parses context-free grammar definitions from a text file.
* **CNF Conversion**: Implements the full multi-step algorithm to convert a grammar to Chomsky Normal Form.
  * Step 1: Eliminate ε-productions.
  * Step 2: Eliminate unit productions.
  * Step 3: Eliminate non-productive symbols.
  * Step 4: Eliminate inaccessible symbols.
  * Step 5: Transform productions into the final CNF structure (`A -> BC` or `A -> a`).
  * Post-CNF Cleanup: Repeats elimination of unit, non-productive, and inaccessible symbols to ensure the final grammar is clean.
* **Step-by-Step Output**: Displays the state of the grammar after each transformation step, aiding in understanding and debugging the process.

## Implementation Description

* **`GrammarParser.java`**: This class is responsible for reading a grammar definition from a string (which is typically loaded from a file). It parses the non-terminal symbols, terminal symbols, and production rules into a `Grammar` object.
* **`CNF.java`**: This class contains the core logic for converting a `Grammar` object into Chomsky Normal Form. It includes methods for each step of the conversion:
  * `eliminateEpsilonProductions()`
  * `eliminateUnitProductions()`
  * `eliminateNonProductiveSymbols()`
  * `eliminateInaccessibleSymbols()`
  * `transformToChomskyForm()` (handles TERM and BIN steps)
  The `convertToCNF()` method orchestrates these steps and includes repeated cleanup phases.
* **`Main.java`**: The entry point of the application. It reads a grammar file path (or uses a default), invokes the `GrammarParser` to parse it, and then calls the `CNF` converter to transform the grammar, printing the results of each stage.
* **Model Classes (`Grammar.java`, `Production.java`, `ProductionSymbol.java`, `SymbolType.java`)**: These record classes define the structure for representing the grammar, its rules, and symbols.

## Conclusion

The Chomsky Normal Form (CNF) project provides a comprehensive implementation of grammar transformation techniques, enabling the conversion of any context-free grammar into a standardized form. By following a structured multi-step process, this project ensures that grammars are optimized for algorithmic applications like parsing and validation. The step-by-step output and modular design make it a valuable tool for understanding and working with formal grammars in computational theory.
